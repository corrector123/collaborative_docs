import{f as v}from"./index-1d500fa5.js";const I=m=>v({url:"/version/createVersion",method:"post",data:m}),y=m=>v({url:"/version/getAllVersions",method:"post",data:m}),D=m=>v({url:"/version/getVersionSnapshot",method:"post",data:m}),j=m=>v({url:"/version/deleteVersion",method:"post",data:m});class M{diff(e,n,t={}){let i;typeof t=="function"?(i=t,t={}):"callback"in t&&(i=t.callback);const a=this.castInput(e,t),u=this.castInput(n,t),d=this.removeEmpty(this.tokenize(a,t)),r=this.removeEmpty(this.tokenize(u,t));return this.diffWithOptionsObj(d,r,t,i)}diffWithOptionsObj(e,n,t,i){var a;const u=s=>{if(s=this.postProcess(s,t),i){setTimeout(function(){i(s)},0);return}else return s},d=n.length,r=e.length;let l=1,o=d+r;t.maxEditLength!=null&&(o=Math.min(o,t.maxEditLength));const P=(a=t.timeout)!==null&&a!==void 0?a:1/0,p=Date.now()+P,c=[{oldPos:-1,lastComponent:void 0}];let f=this.extractCommon(c[0],n,e,0,t);if(c[0].oldPos+1>=r&&f+1>=d)return u(this.buildValues(c[0].lastComponent,n,e));let x=-1/0,L=1/0;const V=()=>{for(let s=Math.max(x,-l);s<=Math.min(L,l);s+=2){let h;const g=c[s-1],C=c[s+1];g&&(c[s-1]=void 0);let _=!1;if(C){const A=C.oldPos-s;_=C&&0<=A&&A<d}const w=g&&g.oldPos+1<r;if(!_&&!w){c[s]=void 0;continue}if(!w||_&&g.oldPos<C.oldPos?h=this.addToPath(C,!0,!1,0,t):h=this.addToPath(g,!1,!0,1,t),f=this.extractCommon(h,n,e,s,t),h.oldPos+1>=r&&f+1>=d)return u(this.buildValues(h.lastComponent,n,e))||!0;c[s]=h,h.oldPos+1>=r&&(L=Math.min(L,s-1)),f+1>=d&&(x=Math.max(x,s+1))}l++};if(i)(function s(){setTimeout(function(){if(l>o||Date.now()>p)return i(void 0);V()||s()},0)})();else for(;l<=o&&Date.now()<=p;){const s=V();if(s)return s}}addToPath(e,n,t,i,a){const u=e.lastComponent;return u&&!a.oneChangePerToken&&u.added===n&&u.removed===t?{oldPos:e.oldPos+i,lastComponent:{count:u.count+1,added:n,removed:t,previousComponent:u.previousComponent}}:{oldPos:e.oldPos+i,lastComponent:{count:1,added:n,removed:t,previousComponent:u}}}extractCommon(e,n,t,i,a){const u=n.length,d=t.length;let r=e.oldPos,l=r-i,o=0;for(;l+1<u&&r+1<d&&this.equals(t[r+1],n[l+1],a);)l++,r++,o++,a.oneChangePerToken&&(e.lastComponent={count:1,previousComponent:e.lastComponent,added:!1,removed:!1});return o&&!a.oneChangePerToken&&(e.lastComponent={count:o,previousComponent:e.lastComponent,added:!1,removed:!1}),e.oldPos=r,l}equals(e,n,t){return t.comparator?t.comparator(e,n):e===n||!!t.ignoreCase&&e.toLowerCase()===n.toLowerCase()}removeEmpty(e){const n=[];for(let t=0;t<e.length;t++)e[t]&&n.push(e[t]);return n}castInput(e,n){return e}tokenize(e,n){return Array.from(e)}join(e){return e.join("")}postProcess(e,n){return e}get useLongestToken(){return!1}buildValues(e,n,t){const i=[];let a;for(;e;)i.push(e),a=e.previousComponent,delete e.previousComponent,e=a;i.reverse();const u=i.length;let d=0,r=0,l=0;for(;d<u;d++){const o=i[d];if(o.removed)o.value=this.join(t.slice(l,l+o.count)),l+=o.count;else{if(!o.added&&this.useLongestToken){let P=n.slice(r,r+o.count);P=P.map(function(p,c){const f=t[l+c];return f.length>p.length?f:p}),o.value=this.join(P)}else o.value=this.join(n.slice(r,r+o.count));r+=o.count,o.added||(l+=o.count)}}return i}}export{M as D,D as a,I as c,j as d,y as g};
