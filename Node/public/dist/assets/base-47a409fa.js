import{f as v}from"./index-2e9e9484.js";const j=m=>v({url:"/version/createVersion",method:"post",data:m}),D=m=>v({url:"/version/getAllVersions",method:"post",data:m}),y=m=>v({url:"/version/getVersionSnapshot",method:"post",data:m}),M=m=>v({url:"/version/deleteVersion",method:"post",data:m});class _{diff(e,n,t={}){let r;typeof t=="function"?(r=t,t={}):"callback"in t&&(r=t.callback);const a=this.castInput(e,t),u=this.castInput(n,t),d=this.removeEmpty(this.tokenize(a,t)),i=this.removeEmpty(this.tokenize(u,t));return this.diffWithOptionsObj(d,i,t,r)}diffWithOptionsObj(e,n,t,r){var a;const u=s=>{if(s=this.postProcess(s,t),r){setTimeout(function(){r(s)},0);return}else return s},d=n.length,i=e.length;let l=1,o=d+i;t.maxEditLength!=null&&(o=Math.min(o,t.maxEditLength));const P=(a=t.timeout)!==null&&a!==void 0?a:1/0,p=Date.now()+P,c=[{oldPos:-1,lastComponent:void 0}];let f=this.extractCommon(c[0],n,e,0,t);if(c[0].oldPos+1>=i&&f+1>=d)return u(this.buildValues(c[0].lastComponent,n,e));let x=-1/0,L=1/0;const w=()=>{for(let s=Math.max(x,-l);s<=Math.min(L,l);s+=2){let h;const g=c[s-1],C=c[s+1];g&&(c[s-1]=void 0);let V=!1;if(C){const I=C.oldPos-s;V=C&&0<=I&&I<d}const A=g&&g.oldPos+1<i;if(!V&&!A){c[s]=void 0;continue}if(!A||V&&g.oldPos<C.oldPos?h=this.addToPath(C,!0,!1,0,t):h=this.addToPath(g,!1,!0,1,t),f=this.extractCommon(h,n,e,s,t),h.oldPos+1>=i&&f+1>=d)return u(this.buildValues(h.lastComponent,n,e))||!0;c[s]=h,h.oldPos+1>=i&&(L=Math.min(L,s-1)),f+1>=d&&(x=Math.max(x,s+1))}l++};if(r)(function s(){setTimeout(function(){if(l>o||Date.now()>p)return r(void 0);w()||s()},0)})();else for(;l<=o&&Date.now()<=p;){const s=w();if(s)return s}}addToPath(e,n,t,r,a){const u=e.lastComponent;return u&&!a.oneChangePerToken&&u.added===n&&u.removed===t?{oldPos:e.oldPos+r,lastComponent:{count:u.count+1,added:n,removed:t,previousComponent:u.previousComponent}}:{oldPos:e.oldPos+r,lastComponent:{count:1,added:n,removed:t,previousComponent:u}}}extractCommon(e,n,t,r,a){const u=n.length,d=t.length;let i=e.oldPos,l=i-r,o=0;for(;l+1<u&&i+1<d&&this.equals(t[i+1],n[l+1],a);)l++,i++,o++,a.oneChangePerToken&&(e.lastComponent={count:1,previousComponent:e.lastComponent,added:!1,removed:!1});return o&&!a.oneChangePerToken&&(e.lastComponent={count:o,previousComponent:e.lastComponent,added:!1,removed:!1}),e.oldPos=i,l}equals(e,n,t){return t.comparator?t.comparator(e,n):e===n||!!t.ignoreCase&&e.toLowerCase()===n.toLowerCase()}removeEmpty(e){const n=[];for(let t=0;t<e.length;t++)e[t]&&n.push(e[t]);return n}castInput(e,n){return e}tokenize(e,n){return Array.from(e)}join(e){return e.join("")}postProcess(e,n){return e}get useLongestToken(){return!1}buildValues(e,n,t){const r=[];let a;for(;e;)r.push(e),a=e.previousComponent,delete e.previousComponent,e=a;r.reverse();const u=r.length;let d=0,i=0,l=0;for(;d<u;d++){const o=r[d];if(o.removed)o.value=this.join(t.slice(l,l+o.count)),l+=o.count;else{if(!o.added&&this.useLongestToken){let P=n.slice(i,i+o.count);P=P.map(function(p,c){const f=t[l+c];return f.length>p.length?f:p}),o.value=this.join(P)}else o.value=this.join(n.slice(i,i+o.count));i+=o.count,o.added||(l+=o.count)}}return r}}export{_ as D,y as a,j as c,M as d,D as g};
